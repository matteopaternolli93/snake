<!DOCTYPE html>
<html>
<head>
  <title>Magic Snake</title>
  <style>
    body {
      margin: 0;
      overflow: hidden;
      background-color: #1C1C1C;
      display: flex;
      justify-content: center;
      align-items: center;
      min-height: 100vh;
      font-family: 'Press Start 2P', cursive; 
    }
    canvas {
      background-color: #282828;
      border: 1px solid #404040;
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      /* Nasconde il canvas inizialmente */
      display: none; 
    }
    .game-element {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      background-color: #282828;
      padding: 80px;
      border-radius: 20px;
      color: #fff;
      text-align: center;
      font-size: 24px;
      z-index: 10;
      box-shadow: 0 0 50px rgba(0, 0, 0, 0.5);
      display: flex;
      flex-direction: column;
      align-items: center;
      width: 80%;
      max-width: 500px;
      height: auto;
      font-family: 'Press Start 2P', cursive; 
    }
    .game-element h2 {
      margin-bottom: 20px;
      font-size: 32px;
      font-weight: bold;
    }
    .game-element p {
      margin-bottom: 30px;
    }
    .game-element button {
      background-color: #FF9800;
      color: white;
      padding: 20px 80px; 
      border: none;
      border-radius: 16px; 
      font-size: 56px; 
      cursor: pointer;
      transition: background-color 0.2s ease;
      margin-top: 20px;
      display: block;
      margin-left: auto;
      margin-right: auto; 
    }
    .game-element button:hover {
      background-color: #FFC107;
    }
    #game-over {
      /* Nasconde il menu di gioco */
      display: none; 
    }
    #start-menu {
      display: block;
    }
    #score {
      font-size: 56px;
      position: absolute;
      top: 60px;
      left: 20px;
      color: white;
      z-index: 10; 
    }
    /* Aggiungi il font */
    body {
      font-family: 'Press Start 2P', cursive; 
    }
  </style>
  <link href="https://fonts.googleapis.com/css2?family=Press+Start+2P&display=swap" rel="stylesheet">
</head>
<body>
  <audio id="eatSound">
    <source src="eat_sound.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="magicEatSound">
    <source src="magic_eat_sound.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <audio id="collisionSound">
    <source src="collision_sound.mp3" type="audio/mpeg">
    Your browser does not support the audio element.
  </audio>
  <div id="start-menu" class="game-element">
    <h2>SNAKE: Magic Food</h2>
    <p>Creato da: Matteo Paternolli</p>
    <button onclick="startGame(4)">Gioca</button> 
  </div>
  <canvas id="gameCanvas"></canvas>
  <div id="game-over" class="game-element">
    <h2>Game Over!</h2>
    <p>Punteggio finale: <span id="final-score"></span></p>
    <button onclick="newGame()">Nuova partita</button>
  </div>
  <div id="score">0</div>
  <script>
    // Definizione delle variabili
    const canvas = document.getElementById('gameCanvas');
    const ctx = canvas.getContext('2d');
    const gameOverScreen = document.getElementById('game-over');
    const scoreElement = document.getElementById('score');
    const finalScoreElement = document.getElementById('final-score');
    const startMenu = document.getElementById('start-menu');
    const eatSound = document.getElementById("eatSound"); 
    const magicEatSound = document.getElementById("magicEatSound");
    const collisionSound = document.getElementById('collisionSound'); 

    const gridSize = 10;
    let cellSize;
    let snake = [{ x: 7, y: 7 }];
    let food = {};
    let magicFood = null;
    let magicFoodTimer = null;
    let direction = 'right';
    let pendingDirection = null;
    let score = 0;
    let gameOver = false;
    let speed = 5; 
    let lastTouchX = 0;
    let lastTouchY = 0;
    let touchStartX = 0;
    let touchStartY = 0;
    let animationFrames = 0;
    let originalSpeed = speed; 
    let foodEatenCounter = 0;

    let gameState = 'start'; 

    let lastUpdateTime = performance.now();
    let frameTime = 1000 / speed;

    let magicFoodGenerationInterval = 10000; // 10 secondi
    let isMagicFoodPresent = false; 

    // Funzione per inizializzare il gioco
    function initializeGame() {
      resizeCanvas();
      generateFood();
      drawGame();
      updateGame();
    }

    // Funzione per adattare la dimensione del canvas alla finestra
    function resizeCanvas() {
      const minDimension = Math.min(window.innerWidth, window.innerHeight);
      canvas.width = minDimension;
      canvas.height = minDimension;
      cellSize = canvas.width / gridSize;
    }

    // Funzione per disegnare un oggetto nel canvas
    function drawObject(x, y, color) {
      ctx.fillStyle = color;
      ctx.fillRect(x * cellSize, y * cellSize, cellSize, cellSize);
      ctx.strokeStyle = color; 
      ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
    }

    // Funzione per disegnare una parte del serpente
    function drawSnakePart(x, y, width, isHead = false) {
      if (magicFood) {
        ctx.fillStyle = isHead ? '#FF0000' : '#FFA500'; // Testa rossa e corpo arancione se ha mangiato cibo magico
      } else {
        ctx.fillStyle = isHead ? '#FFA500' : '#FFFF00'; // Testa arancione e corpo giallo di default
      }

      ctx.fillRect(x * cellSize + (cellSize - width) / 2, 
                   y * cellSize + (cellSize - width) / 2, 
                   width, width);
      ctx.strokeStyle = '#FFFF00'; // Bordo del serpente
      ctx.strokeRect(x * cellSize, y * cellSize, cellSize, cellSize);
    }

    // Funzione per disegnare gli elementi del gioco
    function drawGame() {
      ctx.clearRect(0, 0, canvas.width, canvas.height); // Pulisce il canvas

      // Animazione di quando il serpente mangia
      if (gameState === 'eatingAnimation') {
        animationFrames++;

        if (animationFrames > 5) { 
          gameState = 'playing';
          animationFrames = 0;
        }
      }

      const headWidth = cellSize * (0.6 + animationFrames * 0.1); // Dimensione della testa durante l'animazione

      // Disegna ogni parte del serpente
      for (let i = 0; i < snake.length; i++) {
        drawSnakePart(snake[i].x, snake[i].y, i === 0 ? headWidth : cellSize * 0.6, i === 0);
      }

      drawObject(food.x, food.y, '#00FF00'); // Disegna il cibo normale

      if (magicFood) {
        drawObject(magicFood.x, magicFood.y, '#FF0000'); // Disegna il cibo magico
      }

      requestAnimationFrame(drawGame); // Richiama la funzione per l'animazione
    }

    // Funzione per generare cibo in una posizione casuale
    function generateFood() {
      let isValidPosition = false;
      while (!isValidPosition) {
        food = {
          x: Math.floor(Math.random() * gridSize),
          y: Math.floor(Math.random() * gridSize)
        };

        // Assicurati che il cibo non venga generato sopra il serpente
        isValidPosition = true;
        for (let i = 0; i < snake.length; i++) {
          if (food.x === snake[i].x && food.y === snake[i].y) {
            isValidPosition = false;
            break;
          }
        }
      }
    }

    // Funzione per generare il cibo magico
    function generateMagicFood() {
      // Se il cibo magico è già presente, esci dalla funzione
      if (isMagicFoodPresent) return; 

      // 20% di possibilità di generare cibo magico
      if (Math.random() < 0.20) { 
        magicFood = {
          x: Math.floor(Math.random() * gridSize),
          y: Math.floor(Math.random() * gridSize)
        };

        // Assicurati che il cibo magico non venga generato sopra il cibo normale o il serpente
        while (magicFood.x === food.x && magicFood.y === food.y || 
               snake.some(part => part.x === magicFood.x && part.y === magicFood.y)) {
          magicFood = {
            x: Math.floor(Math.random() * gridSize),
            y: Math.floor(Math.random() * gridSize)
          };
        }

        isMagicFoodPresent = true; 
        // Imposta un timer per far sparire il cibo magico dopo 10 secondi
        magicFoodTimer = setTimeout(() => {
          magicFood = null;
          isMagicFoodPresent = false; 
          startMagicFoodGeneration(); 
        }, 10000); 
      }
    }

    // Funzione per avviare la generazione del cibo magico
    function startMagicFoodGeneration() {
      // Se il cibo magico non è presente, generane uno e imposta l'intervallo di generazione
      if (!isMagicFoodPresent) { 
        generateMagicFood(); 
        setInterval(generateMagicFood, magicFoodGenerationInterval); 
      }
    }

    // Funzione per aggiornare la logica del gioco
    function updateGame(currentTime) {
      if (gameState === 'gameOver') return;

      const elapsedTime = currentTime - lastUpdateTime;

      // Aumenta la velocità del serpente se ha mangiato cibo magico
      let currentSpeed = speed;
      if (magicFood) {
        currentSpeed = speed * 1.5; 
      }

      let frameTime = 1000 / currentSpeed;

      if (elapsedTime >= frameTime) {
        handleDirectionChange(); // Gestisci il cambio di direzione del serpente

        const head = { x: snake[0].x, y: snake[0].y }; // Posizione della testa del serpente

        // Muovi il serpente
        switch (direction) {
          case 'up':
            head.y--;
            break;
          case 'down':
            head.y++;
            break;
          case 'left':
            head.x--;
            break;
          case 'right':
            head.x++;
            break;
        }

        // Gestisci il caso in cui il serpente esce dal canvas
        head.x = (head.x + gridSize) % gridSize;
        head.y = (head.y + gridSize) % gridSize;

        // Aggiungi la nuova posizione della testa all'inizio del serpente
        snake.unshift(head);

        // Controlla se il serpente ha mangiato il cibo
        if (head.x === food.x && head.y === food.y) {
          score++;
          scoreElement.textContent = score;
          generateFood();
          playAudio(eatSound); 
          gameState = 'eatingAnimation'; // Avvia l'animazione di quando mangia
          animationFrames = 0;

          foodEatenCounter++;

          // Aumenta la velocità del serpente ogni 20 cibi mangiati
          if (foodEatenCounter % 20 === 0 && foodEatenCounter > 0) {
            speed++;
            frameTime = 1000 / speed; 
          }
          // Controlla se il serpente ha mangiato il cibo magico
        } else if (magicFood && head.x === magicFood.x && head.y === magicFood.y) {
          score += 5; // Aggiungi 5 punti al punteggio
          scoreElement.textContent = score;

          magicFood = null; // Rimuovi il cibo magico
          clearTimeout(magicFoodTimer); // Cancella il timer del cibo magico

          gameState = 'eatingAnimation';
          animationFrames = 0;

          // Aumenta la lunghezza del serpente di 5 unità
          for (let i = 0; i < 5; i++) {
            snake.push({ x: snake[snake.length - 1].x, y: snake[snake.length - 1].y });
          }

          isMagicFoodPresent = false; 
          playAudio(magicEatSound); 
          // Se il serpente non ha mangiato, rimuovi l'ultima parte del corpo
        } else {
          snake.pop();
        }

        // Controlla se il serpente si è scontrato con se stesso
        if (checkCollision()) {
          gameState = 'gameOver';
          gameOverScreen.style.display = 'block';
          finalScoreElement.textContent = score;
          canvas.style.display = 'none';
          return; 
        }

        lastUpdateTime = currentTime;
        requestAnimationFrame(updateGame);
      } else {
        requestAnimationFrame(updateGame);
      }
    }

    // Gestisci il cambio di direzione, impedendo al serpente di invertire la direzione
    function handleDirectionChange() {
      if (pendingDirection !== null) {
        direction = pendingDirection;
        pendingDirection = null;
      }
    }

    // Controlla se il serpente si è scontrato con se stesso
    function checkCollision() {
      return snake.some((part, index) => {
        if (index > 0 && snake[0].x === part.x && snake[0].y === part.y) {
          playAudio(collisionSound); 
          return true;
        }
        return false;
      });
    }

    // Funzione per iniziare una nuova partita
    function newGame() {
      snake = [{ x: 7, y: 7 }];
      direction = 'right';
      pendingDirection = null;
      score = 0;
      gameState = 'playing'; 
      gameOverScreen.style.display = 'none';
      speed = originalSpeed; 
      frameTime = 1000 / speed;
      foodEatenCounter = 0; 
      scoreElement.textContent = score;
      generateFood();
      canvas.style.display = 'block'; 

      // *** Reset del cibo magico ***
      magicFood = null;
      isMagicFoodPresent = false;
      clearTimeout(magicFoodTimer);

      // Imposta un timer per iniziare la generazione del cibo magico dopo 10 secondi
      setTimeout(() => {
        startMagicFoodGeneration(); 
      }, 10000);

      // *** Chiama initializeGame() per riavviare il gioco ***
      initializeGame(); 
    }

    // Funzione per avviare il gioco
    function startGame(gameSpeed) {
      startMenu.style.display = 'none'; // Nascondi il menu iniziale
      gameState = 'playing';
      speed = gameSpeed;
      originalSpeed = speed;
      frameTime = 1000 / speed; 
      initializeGame();
      canvas.style.display = 'block'; 

      setTimeout(() => {
        startMagicFoodGeneration(); 
      }, 10000); 
    }

    // Funzione per riprodurre un suono
    function playAudio(audioElement) {
      audioElement.currentTime = 0; 
      audioElement.play();
    }

    // Gestione del tocco su schermo
    function handleTouchStart(event) {
      touchStartX = event.touches[0].clientX;
      touchStartY = event.touches[0].clientY;
      lastTouchX = event.touches[0].clientX;
      lastTouchY = event.touches[0].clientY;
    }

    function handleTouchMove(event) {
      const currentTouchX = event.touches[0].clientX;
      const currentTouchY = event.touches[0].clientY;

      const deltaX = currentTouchX - lastTouchX;
      const deltaY = currentTouchY - lastTouchY;

      const swipeThreshold = cellSize * 0.5;
      if (Math.abs(deltaX) > swipeThreshold || Math.abs(deltaY) > swipeThreshold) {
        if (Math.abs(deltaX) > Math.abs(deltaY)) {
          if (deltaX > 0 && direction !== 'left') {
            pendingDirection = 'right';
          } else if (deltaX < 0 && direction !== 'right') {
            pendingDirection = 'left';
          }
        } else {
          if (deltaY > 0 && direction !== 'up') {
            pendingDirection = 'down';
          } else if (deltaY < 0 && direction !== 'down') {
            pendingDirection = 'up';
          }
        }

        lastTouchX = currentTouchX;
        lastTouchY = currentTouchY;
      }
    }

    // Gestione della tastiera
    function handleKeyDown(event) {
      switch (event.key) {
        case 'ArrowUp':
          changeDirection('up');
          break;
        case 'ArrowDown':
          changeDirection('down');
          break;
        case 'ArrowLeft':
          changeDirection('left');
          break;
        case 'ArrowRight':
          changeDirection('right');
          break;
      }
    }

    // Funzione per cambiare la direzione del serpente
    function changeDirection(newDirection) {
      // Impedisci al serpente di invertire la direzione
      if (direction !== getOppositeDirection(newDirection)) {
        pendingDirection = newDirection;
      }
    }

    // Funzione per ottenere la direzione opposta
    function getOppositeDirection(direction) {
      switch (direction) {
        case 'up': return 'down';
        case 'down': return 'up';
        case 'left': return 'right';
        case 'right': return 'left';
      }
    }

    // Event listeners
    window.addEventListener('resize', resizeCanvas);
    window.addEventListener('touchstart', handleTouchStart);
    window.addEventListener('touchmove', handleTouchMove);
    window.addEventListener('keydown', handleKeyDown);
  </script>
</body>
</html>